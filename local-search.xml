<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker封装node项目</title>
    <link href="/2024/10/15/docker%E5%B0%81%E8%A3%85node%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/10/15/docker%E5%B0%81%E8%A3%85node%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="通过docker封装node项目"><a href="#通过docker封装node项目" class="headerlink" title="通过docker封装node项目"></a>通过docker封装node项目</h2><ol><li><p>项目架构</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241016154353081.png" alt="image-20241016154353081"></p></li><li><p>项目根目录创建Dockfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用官方 Node.js 镜像作为基础镜像</span><br>FROM node:18<br><br><span class="hljs-comment"># 设置工作目录</span><br>WORKDIR /app<br><br><span class="hljs-comment"># 复制 package.json 和 package-lock.json 并安装依赖</span><br>COPY package.json package-lock.json ./<br>RUN npm install<br><br><span class="hljs-comment"># 复制项目文件到容器中</span><br>COPY . .<br><br><span class="hljs-comment"># 暴露 3000 端口</span><br>EXPOSE 3000<br><br><span class="hljs-comment"># 启动应用</span><br>CMD [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;src/index.js&quot;</span>]<br><br></code></pre></td></tr></table></figure></li><li><p>编写docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">node-app:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_HOST=mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_USER=xyx</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_PASSWORD=xyx</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_NAME=hospital</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root_password</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">hospital</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql_data:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./hospital.sql:/docker-entrypoint-initdb.d/hospital.sql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./create_user.sql:/docker-entrypoint-initdb.d/create_user.sql</span>  <span class="hljs-comment"># 添加用户创建脚本</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysql_data:</span><br></code></pre></td></tr></table></figure><p><strong>强烈建议不使用root用户链接数据库，这种方式可能链接不上</strong>，所以通过下面的脚本来创建新用户并赋予远程登录权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--- create_user.sql</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;xyx&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;xyx&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;xyx&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p>修改node中链接数据库的方式</p><p>此项目为修改config.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// config.js</span><br><br><span class="hljs-comment">// 启动配置</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// express 服务启动端口</span><br>    <span class="hljs-comment">/* 数据库相关配置 */</span><br>    <span class="hljs-attr">db</span>: &#123;<br>      <span class="hljs-attr">host</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_HOST</span>, <span class="hljs-comment">// 主机名</span><br>      <span class="hljs-attr">port</span>: <span class="hljs-number">3306</span>,        <span class="hljs-comment">// MySQL 默认端口为 3306</span><br>      <span class="hljs-attr">user</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_USER</span>,          <span class="hljs-comment">// 使用  用户登入 MySQL</span><br>      <span class="hljs-attr">password</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_PASSWORD</span>, <span class="hljs-comment">// MySQL 密码，用你自己的</span><br>      <span class="hljs-attr">database</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">DB_NAME</span>, <span class="hljs-comment">// 使用数据库</span><br>      <span class="hljs-attr">timezone</span>: <span class="hljs-string">&quot;08:00&quot;</span>,<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>创建并启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up --build<br></code></pre></td></tr></table></figure><p>这会创建两个容器</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241016155833239.png" alt="image-20241016155833239"></p></li><li><p>访问3000端口，项目部署成功</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241016160151765.png" alt="image-20241016160151765"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>docker快速入门</title>
    <link href="/2024/10/14/docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2024/10/14/docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker快速入门"><a href="#Docker快速入门" class="headerlink" title="Docker快速入门"></a>Docker快速入门</h2><h3 id="1-使用镜像"><a href="#1-使用镜像" class="headerlink" title="1. 使用镜像"></a>1. 使用镜像</h3><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull image<br></code></pre></td></tr></table></figure><blockquote><p>镜像默认保存在 <code>/var/lib/docker/overlay2</code></p></blockquote></li><li><p>运行镜像</p><p>以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18.04 bash<br></code></pre></td></tr></table></figure><p>通过 <code>exit</code> 退出这个容器</p></li><li><p>列出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">ls</span> <br></code></pre></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">rm</span> [<span class="hljs-built_in">id</span>/name]<br></code></pre></td></tr></table></figure><p>可以通过指定镜像名或者镜像id进行删除操作</p></li><li><p>使用Dockerfile定制镜像</p><ol><li><p>创建Dockerfile文件</p></li><li><p>写入</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></code></pre></td></tr></table></figure><blockquote><p>From 指定基础镜像</p><p>RUN 执行shell命令  支持 &amp;&amp; 串联命令  \ 单条命令换</p></blockquote></li><li><p>构建镜像</p><p>在Dockerfile目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t [镜像名] [上下文目录]<br></code></pre></td></tr></table></figure><p><em>上下文目录不是用来指定dockerfile文件所在位置，而是告诉docker创建该镜像要用到哪个目录下的资源</em></p></li></ol></li><li><p>RUN指令细节</p><p>一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; world.txt</span><br></code></pre></td></tr></table></figure><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>,之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p></li></ol><h3 id="2-操作容器"><a href="#2-操作容器" class="headerlink" title="2. 操作容器"></a>2. 操作容器</h3><ol><li><p>启动</p><ol><li><p>新建容器并启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run <br></code></pre></td></tr></table></figure><p> 例如：</p><ul><li><p>打印后终止容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run ubuntu:18.04 /bin/echo <span class="hljs-string">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>启动终端，允许交互</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it ubuntu:18.04  /bin/bash<br></code></pre></td></tr></table></figure><p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开</p></li></ul></li><li><p>启动已经终止的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container start [容器名/容器<span class="hljs-built_in">id</span>]<br></code></pre></td></tr></table></figure><p>该方式启动的容器默认就是在后台运行</p></li></ol></li><li><p>守护态运行</p><p>添加<code>-d</code>参数可以让容器在后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run  -d ubuntu:18.04 /bin/sh -c <span class="hljs-string">&quot;while true; do echo</span><br><span class="hljs-string"> hello world; sleep 1; done&quot;</span><br></code></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p></li><li><p>终止</p><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。并且容器指定的应用终止时，容器也自动终止。</p></li><li><p>进入容器</p><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令。因为attach进入容器后，如果exit会导致进程终止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it [容器] bash<br></code></pre></td></tr></table></figure></li><li><p>导出和导入</p><ul><li><p>导出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> [容器] &gt; ubuntu.tar<br></code></pre></td></tr></table></figure></li><li><p>导入容器</p><p>从容器快照中再导入为镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ubuntu.tar | docker import - <span class="hljs-built_in">test</span>/ubuntu:v1.0<br></code></pre></td></tr></table></figure></li></ul></li><li><p>删除</p><p>删除指定容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">rm</span> [容器]<br></code></pre></td></tr></table></figure><p>删除运行中的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">rm</span> -f [容器]<br></code></pre></td></tr></table></figure><p>清理所有终止态的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container prune<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-数据管理"><a href="#3-数据管理" class="headerlink" title="3. 数据管理"></a>3. 数据管理</h3><ol><li>docker数据卷</li></ol><blockquote><p> 好处: </p><ul><li>容器间可以共享数据卷</li><li>对数据卷的修改会立马生效</li><li>数据卷的修改不会影响镜像</li><li>容器删除后，数据卷依然存在</li></ul></blockquote><ol><li><p>创建数据卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume create [卷名]<br></code></pre></td></tr></table></figure><p>查看数据卷信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume inspect [卷名]<br></code></pre></td></tr></table></figure></li><li><p>将数据卷挂载到容器中</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v my-vol:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">source</span>=my-vol,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure></li><li><p>删除卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume <span class="hljs-built_in">rm</span> my-vol<br></code></pre></td></tr></table></figure><p>清除无主数据卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume prune<br></code></pre></td></tr></table></figure></li><li><p>将主机目录作为数据卷</p><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P \<br>    --name web \<br>    <span class="hljs-comment"># -v /src/webapp:/usr/share/nginx/html \</span><br>    --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/src/webapp,target=/usr/share/nginx/html \<br>    nginx:alpine<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-使用网络"><a href="#4-使用网络" class="headerlink" title="4. 使用网络"></a>4. 使用网络</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -P nginx:alpine<br><br>$ docker container <span class="hljs-built_in">ls</span> -l<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES<br>fae320d08268        nginx:alpine        <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty<br></code></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> logs<span class="hljs-meta"> [容器]</span><br></code></pre></td></tr></table></figure><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 80:80 nginx:alpine<br></code></pre></td></tr></table></figure><p>左侧为主机端口，右侧为容器端口</p><p>动过port查看容器的端口映射情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker port [容器]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机的不同网络模式</title>
    <link href="/2024/10/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/10/06/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-桥接模式"><a href="#1-桥接模式" class="headerlink" title="1. 桥接模式"></a>1. 桥接模式</h2><p>桥接模式下的虚拟机使用的网卡就是<strong>宿主机的物理网卡</strong>，该虚拟机下的ip地址的<strong>网段要和宿主机相同</strong></p><h2 id="2-NAT模式"><a href="#2-NAT模式" class="headerlink" title="2. NAT模式"></a>2. NAT模式</h2><p>NAT模式下，虚拟机的<strong>网段和宿主机不同</strong>，通过虚拟网卡链接宿主机的物理网卡</p><p>图解：</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006222247983.png" alt="image-20241006222247983"></p><p>注意事项：</p><ul><li>同一网段的设备能相互通信，如虚拟机A、物理机A、物理机B之间可以相互ping通</li><li>下一级的网段能够访问上一级的网段，如虚拟机B能够向上访问虚拟机A、物理机A、物理机B，反之，则只有物理机B能够访问虚拟机B，其他不能</li></ul><p>如何在终端配置虚拟机的网卡？</p><p>以ens33为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006222902060.png" alt="image-20241006222902060"></p><p>主要修改ip、掩码、网关</p><p>修改完成后要<strong>重启系统</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络常识</title>
    <link href="/2024/10/06/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%AF%86/"/>
    <url>/2024/10/06/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ip地址和子网掩码"><a href="#1-ip地址和子网掩码" class="headerlink" title="1. ip地址和子网掩码"></a>1. ip地址和子网掩码</h2><p><strong>ip地址</strong>：用于标识网络中的不同设备，包括网段号和主机号两部分</p><p><strong>子网掩码</strong>：用于划分ip地址中的网段号和主机号, 也可以直接指定网段号的位数</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006215630660.png" alt="image-20241006215630660"></p><h2 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h2><p>什么时候需要网关？</p><p><strong>不同网段</strong>之间的设备的通信需要网关，网关是<strong>软件层面的路由器</strong></p><p>在windows中测试访问某个ip需要经过哪些网关</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">tracert -d &lt;ip地址&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo发布文章</title>
    <link href="/2024/10/06/hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/06/hexo%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<ol><li><p>在hexo文件夹中打开git bash</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006145140759.png" alt="image-20241006145140759"></p></li><li><p>创建文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo n &#x27;title&#x27;<br></code></pre></td></tr></table></figure></li><li><p>编辑文章</p></li><li><p>发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo d -g<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker无法拉取镜像</title>
    <link href="/2024/10/06/docker%E6%97%A0%E6%B3%95%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%95%9C%E5%83%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2024/10/06/docker%E6%97%A0%E6%B3%95%E6%8B%89%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%95%9C%E5%83%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="docker无法拉取远程镜像解决方案"><a href="#docker无法拉取远程镜像解决方案" class="headerlink" title="docker无法拉取远程镜像解决方案"></a>docker无法拉取远程镜像解决方案</h1><blockquote><p>操作系统：wsl2  Ubuntu-20.04</p><p>docker版本： 27.3.1</p></blockquote><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006141905814.png" alt="image-20241006141905814"></p><p>尝试拉取nginx镜像失败</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p><a href="https://developer.aliyun.com/article/1579545">解决方案</a></p><ol><li>修改<code>/etc/docker/daemon.json</code></li></ol><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006142518555.png" alt="image-20241006142518555"></p><ol start="2"><li><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>拉取成功</p></li></ol><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20241006142647893.png" alt="image-20241006142647893"></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer</title>
    <link href="/2024/08/08/Transformer/"/>
    <url>/2024/08/08/Transformer/</url>
    
    <content type="html"><![CDATA[<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><h2 id="1-seq2seq模型"><a href="#1-seq2seq模型" class="headerlink" title="1. seq2seq模型"></a>1. seq2seq模型</h2><p>seq2seq模型是一种用于将一个序列转换为另一个序列的深度学习架构。这种模型最常用于需要输入和输出都是可变长度序列的任务，比如机器翻译、文本生成和语音识别。</p><h2 id="2-encode"><a href="#2-encode" class="headerlink" title="2. encode"></a>2. encode</h2><p>输入一组向量，输出一组向量</p><p>encode的内部结构</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808215727425.png" alt="image-20240808215727425"></p><p>每个block包括一个<strong>自注意力层</strong>和<strong>全连接神经网络层</strong></p><p>但是transformer的encode做了一些额外的操作：</p><ul><li>residual connection : 某一层的输出向量会加上该层的输入向量</li><li>layer normalization: 向量中的元素会进行归一化处理（正态分布）</li></ul><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808220142197.png" alt="image-20240808220142197"></p><h2 id="3-decode"><a href="#3-decode" class="headerlink" title="3. decode"></a>3. decode</h2><p>结构encode的输出和decode前一步的输出，产生新的输出</p><p>**masked self-attention:**由于decode产生的新输出之能依赖于之前已经产生的输出，所以自注意力只能关注已经生成的向量</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808221501847.png" alt="image-20240808221501847"></p><p><strong>如何自动结束继续生成：</strong></p><p>END标识来终止继续生成，机器需要自己推断END产生的时机</p><blockquote><p>AT decode的输出是一个接一个产生的，而 NAT decode是一次性输出一整个完整的句子，但是NAT的表现不如AT</p></blockquote><p><strong>cross attention:</strong> decode 的 输出向量 和 encode 的输出 进行注意力机制</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808223440106.png" alt="image-20240808223440106"></p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808223554830.png" alt="image-20240808223554830"></p><p><strong>训练时将正确答案作为decode的输入：</strong></p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808224104140.png" alt="image-20240808224104140"></p><p><strong>exposure bias：</strong> 暴露偏差指的是序列生成模型在训练时与推理时的输入差异。训练时使用真实的输入序列，但在推理时，模型需要使用自己的预测结果作为输入，这可能导致模型性能下降。</p><p>解决方案：Scheduled Sampling 通过在训练过程中逐渐引入模型的预测结果作为输入来缓解暴露偏差问题。它是一种介于教师强制和完全自我回归（autoregressive）方法之间的训练策略。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning 2021 Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Self-Attention</title>
    <link href="/2024/08/08/Self-Attention/"/>
    <url>/2024/08/08/Self-Attention/</url>
    
    <content type="html"><![CDATA[<h1 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h1><h2 id="1-输入是向量的集合"><a href="#1-输入是向量的集合" class="headerlink" title="1. 输入是向量的集合"></a>1. 输入是向量的集合</h2><ul><li>文本处理，每个字由一个向量表示</li><li>语音处理，每段语音由一个向量表示</li><li>等</li></ul><h2 id="2-输出label数量"><a href="#2-输出label数量" class="headerlink" title="2. 输出label数量"></a>2. 输出label数量</h2><ul><li>每个输入对应一个输出：如词性分析</li><li>若干个输入对应一个输出：如句子的褒贬分析</li><li>由机器决定输出label数量</li></ul><h2 id="3-self-attention"><a href="#3-self-attention" class="headerlink" title="3. self-attention"></a>3. self-attention</h2><blockquote><p>在文本处理中，对一个词的分析往往需要考虑其上下文，甚至某些词需要考虑整个段落，self-attention的提出就是为了让每个词都考虑整个段落而提出的</p></blockquote><p>self-attention的流程如下：</p><ol><li><p>计算当前词和其他词的关联程度，得到一个attention score，并经过softmax</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808185157110.png" alt="image-20240808185157110"></p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808185245657.png" alt="image-20240808185245657"></p></li><li><p>计算每个词的value</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808185323383.png" alt="image-20240808185323383"></p></li><li><p>将每个词的value乘上attention score并累加</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808185347685.png" alt="image-20240808185347685"></p></li><li><p>每个输入是同时经过self-attention层的</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808185451894.png" alt="image-20240808185451894"></p></li></ol><p>矩阵运算</p><ul><li><p>QKV矩阵</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808194758616.png" alt="image-20240808194758616"></p></li><li><p>attentioin score矩阵</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808194953061.png" alt="image-20240808194953061"></p></li><li><p>输出矩阵</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808195052485.png" alt="image-20240808195052485"></p></li></ul><p>综上：公式为</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808195125689.png" alt="image-20240808195125689"></p><h2 id="4-multi-head-self-attention"><a href="#4-multi-head-self-attention" class="headerlink" title="4. multi-head self-attention"></a>4. multi-head self-attention</h2><p><strong>词语之间可能不止一种相关性</strong>，即W矩阵组可能不止一组，<strong>每一组W矩阵组称为一个head</strong>，不同组之间的运算相互独立</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808195435383.png" alt="image-20240808195435383"></p><p>经过不同W组产生的输出向量(b向量),拼接后再与矩阵相乘进行降维</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808195715410.png" alt="image-20240808195715410"></p><h2 id="5-positional-encoding"><a href="#5-positional-encoding" class="headerlink" title="5. positional encoding"></a>5. positional encoding</h2><p>为了体现词在整个序列中的位置，需要引入位置编码，做法是将位置编码加上词向量</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808195913767.png" alt="image-20240808195913767"></p><p>位置编码通常通过sin cos函数尝试，也可以通过学习产生</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning 2021 Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自注意力机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习入门</title>
    <link href="/2024/08/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
    <url>/2024/08/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="1-什么是机器学习"><a href="#1-什么是机器学习" class="headerlink" title="1. 什么是机器学习"></a>1. 什么是机器学习</h2><h3 id="1-1-概括"><a href="#1-1-概括" class="headerlink" title="1.1 概括"></a>1.1 概括</h3><p>让机器具备找一个函数的能力，给机器一个输入，机器能够得到一个输出</p><p><strong>这种函数极为复杂， 需要借助机器实现</strong></p><h3 id="1-2-种类"><a href="#1-2-种类" class="headerlink" title="1.2 种类"></a>1.2 种类</h3><ul><li><p>regression 回归</p></li><li><p>classification 分类</p></li><li><p>strctured learning 创造</p></li></ul><h3 id="1-3-如何实现函数"><a href="#1-3-如何实现函数" class="headerlink" title="1.3 如何实现函数"></a>1.3 如何实现函数</h3><p>以预测youtube的视频观看人数为例</p><ol><li><p>定义一个带有未知参数的函数，根据直观经验进行假设</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805164233463.png" alt="image-20240805164233463"></p></li><li><p>损失函数（loss function），检验模型的效果</p></li><li><p>优化（optimization），<strong>梯度下降</strong>是常用的手段</p><p>hyperparameters: 在机器学习中，需要认为设定的参数，如学习率、训练次数</p><p>梯度下降的局部最小值是一个假问题？</p><blockquote><p>采用更多的feature能够得到loss更小的model：用前7天的数据作为feature比只用前1天的数据作为feature得到的模型更好</p></blockquote></li></ol><h3 id="1-4-优化线性函数（神经网络）"><a href="#1-4-优化线性函数（神经网络）" class="headerlink" title="1.4 优化线性函数（神经网络）"></a>1.4 优化线性函数（神经网络）</h3><p>线性函数显然无法解决所有问题，一个连续函数通常也不是只有</p><ol><li><p>对于曲线可以通过以直代曲的方式，用0折线去逼近</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805173650782.png" alt="image-20240805173650782"></p></li><li><p>分段折线可以由多个不同的hard sigmoid函数叠加而成</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805173726042.png" alt="image-20240805173726042"></p></li><li><p>hard sigmoid 函数可以由 sigmoid函数近似</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805173741786.png" alt="image-20240805173741786"> **综上： ** <strong>通过叠加不同的sigmoid函数，能够近似出所有连续函数</strong></p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805173851781.png" alt="image-20240805173851781"></p></li></ol><p>流程图及矩阵表示</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805173959426.png" alt="image-20240805173959426"></p><blockquote><p>gradient : 损失函数对各个参数的导数组成的向量</p></blockquote><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805174743696.png" alt="image-20240805174743696"></p><h3 id="1-4-分批训练"><a href="#1-4-分批训练" class="headerlink" title="1.4 分批训练"></a>1.4 分批训练</h3><p>通常将一批（epoch）数据分为n个组（batch），每个组包含若干个样本，每个batch作为一次参数更新使用</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240805180052506.png" alt="image-20240805180052506"></p><h2 id="2-模型问题"><a href="#2-模型问题" class="headerlink" title="2. 模型问题"></a>2. 模型问题</h2><h3 id="2-1-training-data-loss-偏大"><a href="#2-1-training-data-loss-偏大" class="headerlink" title="2.1 training data loss 偏大"></a>2.1 training data loss 偏大</h3><p>这种情况通常是模型的<strong>特征较少</strong>，或者<strong>参数优化</strong>没做好（梯度下降的局部最小值</p><h3 id="2-2-test-data-loss-偏大"><a href="#2-2-test-data-loss-偏大" class="headerlink" title="2.2 test data loss 偏大"></a>2.2 test data loss 偏大</h3><p>这种情况通常是模型<strong>过拟合</strong></p><p>解决方案：</p><ul><li>减少模型参数（神经元数目</li><li>减少样本数量</li><li>early stopping</li><li>regularization</li><li>dropout</li></ul><blockquote><p>限制过多，模型又会出现欠拟合</p></blockquote><h2 id="3-模型优化"><a href="#3-模型优化" class="headerlink" title="3. 模型优化"></a>3. 模型优化</h2><h3 id="3-1-local-minima-和-saddle-point"><a href="#3-1-local-minima-和-saddle-point" class="headerlink" title="3.1 local minima 和 saddle point"></a>3.1 local minima 和 saddle point</h3><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240806213930648.png" alt="image-20240806213930648"></p><p>saddle point 处的导数为0，但是不属于最小值处，该点可以继续优化</p><h4 id="如何区分该点是否为saddle-point"><a href="#如何区分该点是否为saddle-point" class="headerlink" title="如何区分该点是否为saddle point"></a>如何区分该点是否为saddle point</h4><ol><li>计算Hessian metrix, 其中每一元素是对LOSS函数的二阶微分</li></ol><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240806221045878.png" alt="image-20240806221045878"></p><ol start="2"><li><p>计算 Hessian metrix 特征值</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240806221226576.png" alt="image-20240806221226576"></p></li></ol><blockquote><p>局部最小值为什么是假问题：</p><p>通常情况下，神经网络的参数维度成百上千，巨大多数点都为saddle point</p></blockquote><h3 id="3-2-batch"><a href="#3-2-batch" class="headerlink" title="3.2 batch"></a>3.2 batch</h3><h4 id="为什么要用batch"><a href="#为什么要用batch" class="headerlink" title="为什么要用batch"></a>为什么要用batch</h4><p>比较batch size的大小，大的size的运算一批时间小， <strong>因为GPU可以进行平行运算</strong>，大的size更新次数少；</p><p>但是小size的效果往往更好</p><ul><li><p>参数优化的效果更好，因为更新次数多，而每次更新采用的是不同的loss函数，如果参数停在了saddle point, 新的loss可能会让参数走出saddle point</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240807110539215.png" alt="image-20240807110539215"></p></li><li><p>small size 在测试集上的效果更好</p></li></ul><h3 id="3-3-momentum"><a href="#3-3-momentum" class="headerlink" title="3.3 momentum"></a>3.3 momentum</h3><p>解决local minima 和 saddle point 的另一种手段</p><p><strong>通过叠加上一步移动的方向和当前梯度的反方向来决定这一步要走的方向</strong></p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240807111509579.png" alt="image-20240807111509579"></p><h3 id="3-4-learning-rate"><a href="#3-4-learning-rate" class="headerlink" title="3.4 learning rate"></a>3.4 learning rate</h3><ul><li>学习率过大，参数在“山谷“之间来回震荡，无法达到最小值</li><li>学习率过小，对于平缓的“坡度”loss机会无法减小</li></ul><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240807172346742.png" alt="image-20240807172346742"></p><h4 id="如何让学习率自适应"><a href="#如何让学习率自适应" class="headerlink" title="如何让学习率自适应"></a>如何让学习率自适应</h4><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240807173559121.png" alt="image-20240807173559121"></p><p><strong>将当前点的梯度作为学习率的分母的一部分</strong></p><blockquote><p>Adam：集合学习率自适应和方向自适应的优化策略</p></blockquote><h2 id="4-分类问题"><a href="#4-分类问题" class="headerlink" title="4. 分类问题"></a>4. 分类问题</h2><h3 id="4-1-标签如何表示"><a href="#4-1-标签如何表示" class="headerlink" title="4.1 标签如何表示"></a>4.1 标签如何表示</h3><p>采用向量表示不同类，常用的编码方式为独热码</p><h3 id="4-2-softmax"><a href="#4-2-softmax" class="headerlink" title="4.2 softmax"></a>4.2 softmax</h3><p>nn输出的向量（logits）还需要经过softmax操作，才能和label进行比较</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240807175417178.png" alt="image-20240807175417178"></p><p>作用：</p><ul><li>将所有数字至于0-1</li><li>所有数字和为1</li><li>将大的数和小的数的差距拉大</li></ul><h3 id="4-3-cross-entropy-交叉熵"><a href="#4-3-cross-entropy-交叉熵" class="headerlink" title="4.3 cross-entropy (交叉熵)"></a>4.3 cross-entropy (交叉熵)</h3><p>对于分类问题，更常用的是采用交叉熵来定义loss function</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240807175808320.png" alt="image-20240807175808320"></p><h2 id="5-normalization"><a href="#5-normalization" class="headerlink" title="5. normalization"></a>5. normalization</h2><p>Normalization（归一化）技术在深度学习中被广泛使用，以改善模型的训练速度和稳定性。通过对数据或网络层进行归一化，可以使模型更容易优化并提高其泛化能力。</p><p><strong>特征归一化</strong>：对一批样本的<strong>同一维数据</strong>转化为正态分布</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808213951984.png" alt="image-20240808213951984"></p><p><strong>Batch Normalization</strong>:</p><p>神经网络中，不仅要对输入层的数据做归一化，<strong>还要对中间层的数据做归一化</strong>，而归一化需要所有用到的数据，按照一个batch进行归一化的操作为batch normalization</p><p><img src="https://raw.githubusercontent.com/xyx138/cloudimg/master/img/image-20240808214327535.png" alt="image-20240808214327535"></p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning 2021 Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
